# 메시지 브로커로서의 Redis


## **1. 분산 시스템에서의 메시지 브로커의 등장 배경**

### 현대의 소프트웨어 아키텍처 마이크로서비스 아키텍처(MSA)
1. **거대 단일 구조(Monolithic)** 에서 **마이크로서비스 아키텍처(MSA)** 로 변화
2. 서비스 간 통신의 복잡성은 기하급수적으로 증가
3. 이러한 환경에서 시스템의 결합도를 낮추고 탄력성을 확보하기 위한 핵심 컴포넌트로 메시지 브로커 등장

### **1.1 메시지 큐(Message Queue)와 메시지 브로커(Message Broker)의 존재론적 구분**

업계에서 메시지 큐와 메시지 브로커는 혼용되어 사용되는 경향이 있으나, 아키텍처 관점에서는 명확한 기능적, 구조적 차이가 존재한다.

**메시지 큐(Message Queue)**
- 데이터를 일시 저장하는 수동적인 데이터 구조(Passive Data Structure)다.
- 선입선출(FIFO) 방식의 버퍼로서, 생산자(Producer)가 넣은 데이터를 소비자(Consumer)가 가져갈 때까지 보관하는 저장소 역할이다.
- 큐 자체는 메시지의 내용을 이해하거나, 수신자의 상태를 능동적으로 판단하여 라우팅 경로를 변경하는 등의 로직을 수행하지 않는다. 
- Redis의 List 자료구조가 이 범주에 속하며, 이는 단순히 빠른 입출력을 지원하는 버퍼로 기능한다.

출처: https://threedots.tech/episode/sync-vs-async/

출처: https://redis.io/solutions/message-broker-pattern-for-microservices-interservice-communication/

**메시지 브로커(Message Broker)**
- 메시지의 수신, 검증, 변환, 라우팅 및 전달 확인을 수행하는 **능동적인 미들웨어(Active Middleware)** 이다. 
- 브로커는 단순한 저장소를 넘어, 생산자와 소비자 사이의 계약을 관리한다. 
  - 여기에 메시지 패턴(Pub/Sub 등)에 따른 다중 전달, 소비자 그룹(Consumer Group) 관리를 통한 부하 분산, 그리고 장애 발생 시 재시도(Retry) 및 배달 못한 메시지(Dead Letter) 처리 등의 오케스트레이션 로직이 포함된다.
- Redis는 초기에는 단순한 키-값 저장소 및 큐로 활용되었으나, Pub/Sub 및 Streams의 도입을 통해 메시지의 생명주기를 관리하고 소비 상태를 추적하는 완전한 메시지 브로커로서 입지를 굳혔다.

출처: https://redis.io/solutions/message-broker-pattern-for-microservices-interservice-communication/

출처: https://redis.io/blog/what-to-choose-for-your-synchronous-and-asynchronous-communication-needs-redis-streams-redis-pub-sub-kafka-etc-best-approaches-synchronous-asynchronous-communication/

출처: https://intellisoft.io/rabbitmq-vs-kafka-choosing-the-right-messaging-system-for-your-needs/

### **1.2 동기(Synchronous) 대 비동기(Asynchronous) 통신의 아키텍처적 결합도**

시스템 설계에서 통신 방식의 선택은 서비스 간의 결합도(Coupling)와 전체 시스템의 응답 시간(Latency)을 결정짓는 가장 중요한 변수이다.

- **동기 통신(Synchronous Communication)** 은 HTTP 요청과 같이 클라이언트가 요청을 보내고 응답이 올 때까지 대기(Blocking)하는 구조이다.
- **시간적 결합(Temporal Coupling):** 요청자와 처리자가 동시에 온라인 상태여야 한다. 하위 서비스의 장애는 즉시 상위 서비스의 장애로 전파된다.
- **지연 시간의 누적:** 서비스 A가 서비스 B를 호출하고, B가 데이터베이스 C를 호출하는 경우, 최종 응답 시간은 $T_{total} = T_A + T_B + T_C$가 된다. 이는 사용자 경험을 저하시키는 주요 원인이 된다. 
- **비동기 통신(Asynchronous Communication)** 은 메시지 브로커를 매개로 하여 생산자와 소비자의 실행 흐름을 분리한다.
- **공간적/시간적 분리:** 생산자는 메시지를 브로커에 '발행(Publish)'하고 즉시 자신의 작업을 계속한다. 소비자가 현재 오프라인이거나 과부하 상태라 하더라도 생산자의 로직 수행에는 영향을 주지 않는다.
- **탄력성(Resilience):** 트래픽 스파이크(Traffic Spike) 발생 시, 브로커가 버퍼 역할을 수행하여 소비자가 처리 가능한 속도로 메시지를 가져가게 함으로써 시스템 전체의 붕괴를 방지한다.
- **지연 시간 은폐:** 사용자의 체감 응답 시간은 '브로커에 메시지를 저장하는 시간'(수 밀리초)으로 단축되며, 실제 무거운 처리는 백그라운드에서 수행된다.

 출처: https://threedots.tech/episode/sync-vs-async/
 
 출처: https://redis.io/solutions/message-broker-pattern-for-microservices-interservice-communication/
 
 출처: https://risingwave.com/blog/google-cloud-pub-sub-vs-redis-streams-pros-and-cons/


### **1.3 배압(Backpressure) 조절과 시스템 안정성**

배압(Backpressure)은 데이터의 유입 속도가 처리 속도를 초과할 때($Rate_{produce} > Rate_{consume}$), 시스템이 이를 감지하고 유입 속도를 조절하거나 데이터를 버퍼링하여 안정성을 유지하는 메커니즘이다.

메시지 브로커 없이 직접 통신하는 구조에서는 소비자가 감당할 수 없는 요청이 들어오면 메모리 초과(OOM)나 스레드 고갈로 인해 서비스가 중단된다. Redis와 같은 브로커는 이 상황에서 **충격 흡수 장치(Shock Absorber)** 역할을 수행한다.

1. **버퍼링(Buffering):** 소비자가 처리하지 못한 메시지는 Redis의 메모리(Streams 또는 List)에 큐잉된다. 이는 일시적인 트래픽 폭주를 시스템 장애가 아닌 '처리 지연'으로 변환시킨다.
2. **소비자 주도 처리(Pull-based Consumption):** Redis Streams와 같은 구조는 소비자가 자신의 처리 능력에 맞춰 XREAD 명령을 통해 명시적으로 메시지를 가져오는 풀(Pull) 방식을 지원한다. 이는 생산자가 소비자를 압도하는 것을 방지한다.
3. **흐름 제어(Flow Control):** MAXLEN 설정을 통해 큐의 크기를 제한함으로써, 메모리가 무한정 증가하는 것을 방지하고 오래된 데이터를 희생하여 시스템 전체의 생존을 우선시하는 전략을 취할 수 있다.

출처: https://threedots.tech/episode/sync-vs-async/

출처: https://medium.com/@jayphelps/backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7

출처: https://docs.spring.io/spring-data/redis/reference/redis/redis-streams.html

출처: https://stackoverflow.com/questions/56420506/how-to-use-backpressure-with-redis-streams

---

## **2. Redis의 메시지 처리 패턴 (Redis Messaging Patterns)**

Redis는 단순한 큐잉부터 복잡한 스트림 처리까지 지원하는 세 가지 주요 메시징 패턴을 제공한다. 각 패턴은 고유한 아키텍처적 장단점과 사용 사례를 가지며, 이를 적절히 선택하는 것이 시스템 설계의 핵심이다.

### **2.1 Pattern A: List (Queue) – 1:1 통신의 한계와 단순성**

Redis의 List 자료구조(Linked List 또는 ZipList 기반)를 사용하는 방식은 가장 원시적이지만 직관적인 큐 구현체이다.

- **구현 메커니즘:** 생산자는 LPUSH로 메시지를 리스트의 헤드에 넣고, 소비자는 RPOP (또는 블로킹 버전인 BRPOP)으로 테일에서 메시지를 꺼낸다.
- **1:1 통신 구조:** 이 패턴의 가장 결정적인 특징은 **소비의 파괴성(Destructive Read)**이다. 소비자가 RPOP을 수행하는 순간, 해당 데이터는 Redis 메모리에서 영구적으로 삭제되어 클라이언트로 전송된다. 따라서 하나의 메시지는 오직 하나의 소비자에게만 전달될 수 있다. 이는 작업 대기열(Task Queue)과 같이 하나의 작업이 중복 처리되지 않아야 하는 경우에는 적합하지만, 다중 목적을 위해 데이터를 공유해야 하는 이벤트 기반 아키텍처에는 부적합하다.
- **신뢰성 문제:** 메시지를 꺼내간(POP) 소비자가 처리 도중 비정상 종료될 경우, 해당 메시지는 이미 Redis에서 삭제되었으므로 영구적으로 유실된다. 이를 방지하기 위해 RPOPLPUSH와 같은 안전장치가 존재했으나, 구현이 복잡하고 현대적인 요구사항을 충족하기 어렵다.


출처: https://www.reddit.com/r/softwarearchitecture/comments/1nw3e1h/stop_confusing_redis_pubsub_with_streams/

출처: https://antirez.com/news/114

### **2.2 Pattern B: Pub/Sub – Fire-and-Forget과 데이터 유실의 허용**

Redis Pub/Sub(Publish/Subscribe)은 1:N(일대다) 통신을 지원하여 List의 한계를 극복했으나, 근본적으로 **데이터를 저장하지 않는** 아키텍처를 채택했다.

- **구현 메커니즘:** 생산자가 특정 채널(Channel)에 메시지를 발행(PUBLISH)하면, Redis는 해당 채널을 구독(SUBSCRIBE)하고 있는 모든 연결된 클라이언트에게 즉시 메시지를 밀어넣는다(Push).
- **Fire-and-Forget (쏘고 잊기):** 아키텍처적으로 Pub/Sub의 채널은 데이터 저장소가 아니라 **라우팅 키(Routing Key)**에 불과하다. Redis는 메시지를 소켓에 쓴 직후 메모리에서 폐기한다. 따라서 구독자가 오프라인 상태이거나 네트워크 단절로 연결이 끊긴 동안 발생한 메시지는 **전량 유실**된다.
- **전달 보장 수준:** '최대 1회(At-most-once)' 전달만을 보장한다. 즉, 메시지는 전달되거나, 혹은 영원히 사라진다.
- **적합성 분석:** 이 모델은 채팅방의 메시지 전송, 실시간 주식 시세 업데이트, 시스템 간의 휘발성 알림과 같이 "과거의 데이터가 현재 시점에서 중요하지 않은" 경우에만 아키텍처적으로 용인된다. 데이터의 영속성이 필수적인 비즈니스 로직에는 사용할 수 없다.

출처: https://www.reddit.com/r/softwarearchitecture/comments/1nw3e1h/stop_confusing_redis_pubsub_with_streams/

출처: https://stackoverflow.com/questions/59540563/what-are-the-main-differences-between-redis-valkey-pub-sub-and-streams

출처: https://redis.io/docs/latest/develop/pubsub/

출처: https://double.cloud/blog/posts/2024/02/redis-vs-kafka/

<img width="1080" height="541" alt="image" src="https://github.com/user-attachments/assets/edb46dec-8adb-4f60-a86b-0b336d8c1ba8" />


### **2.3 Pattern C: Streams – 로그 자료구조를 통한 영속성과 멀티 컨슈머 지원**

Redis 5.0에서 도입된 Streams는 Apache Kafka의 설계 철학인 **로그 자료구조(Log Data Structure)**를 인메모리 데이터베이스에 구현한 혁신적인 모델이다.

- **데이터 영속성(Persistence):** Streams는 'Append-only Log'이다. 메시지는 고유한 ID(타임스탬프-일련번호)를 가지며 스트림에 순차적으로 저장된다. 소비자가 메시지를 읽더라도(XREAD) 데이터는 삭제되지 않고 메모리에 유지된다. 이를 통해 소비자는 언제든지 과거의 데이터 시점으로 돌아가서 재처리가 가능하다(Time-Travel).
- **멀티 컨슈머(1:N) 지원:** 데이터가 유지되므로, 서로 다른 목적을 가진 여러 소비자 그룹(예: '로그 아카이빙 그룹'과 '실시간 분석 그룹')이 동일한 스트림 데이터를 각자의 속도에 맞춰 독립적으로 읽을 수 있다. 이는 Kafka의 토픽(Topic) 개념과 유사하게 동작하며, 하나의 데이터 소스로부터 다양한 파생 데이터를 생성하는 팬아웃(Fan-out) 아키텍처를 가능하게 한다.
- **소비자 그룹(Consumer Group):** 단순한 팬아웃을 넘어, 하나의 논리적 그룹 내에서 여러 소비자가 메시지를 분담하여 처리하는 샤딩(Sharding) 모델을 지원한다. 이는 대규모 트래픽 처리를 위한 스케일 아웃(Scale-out)의 기반이 된다.

| **기능** | **List (Queue)** | **Pub/Sub** | **Streams** |
| --- | --- | --- | --- |
| **통신 모델** | 1:1 (Competing) | 1:N (Broadcasting) | 1:N (Log w/ Groups) |
| **데이터 영속성** | 없음 (POP 시 삭제) | 없음 (즉시 휘발) | 있음 (명시적 삭제 전까지 유지) |
| **소비 방식** | Pull (능동적) | Push (수동적) | Pull (능동적/블로킹) |
| **장애 복구** | 어려움 (유실 가능성 高) | 불가능 (오프라인 시 유실) | 강력함 (PEL/재처리 지원) |
| **메모리 효율** | 보통 | 매우 높음 (저장 안함) | 매우 높음 (Radix Tree 압축) |

출처: https://redis.io/solutions/message-broker-pattern-for-microservices-interservice-communication/

출처: https://redis.io/docs/latest/develop/data-types/streams/

출처: https://redis.io/resources/understanding-streams-in-redis-and-kafka-ebook.pdf

출처: https://blog.stackademic.com/redis-stream-with-go-from-queue-creation-to-reliable-message-retries-65ad5ac71c0c

---

## **3. Redis Streams 심층 분석 (Deep Dive into Streams)**

Redis Streams가 단순한 리스트나 배열이 아닌 고성능 브로커로 동작할 수 있는 이유는 내부적인 데이터 구조와 상태 관리 메커니즘의 정교함에 있다. 본 장에서는 Radix Tree의 효율성, 소비자 그룹의 동작 원리, 그리고 장애 복구를 위한 PEL의 메커니즘을 상세히 분석한다.

### **3.1 Radix Tree (Rax) 구조와 메모리 효율성**

Redis Streams는 내부적으로 **Radix Tree (기수 트리)**, 구체적으로는 Redis 소스 코드 내에서 **Rax**라고 불리는 변형된 구현체를 사용하여 데이터를 저장한다. 왜 단순한 배열이나 해시맵이 아닌 Radix Tree를 선택했는가?

1. **키(Key)의 특성과 압축:** Stream의 ID는 1678900012656-0과 같이 타임스탬프 기반으로 생성된다. 이는 연속된 메시지들이 앞부분의 타임스탬프(밀리초 단위)를 공유할 확률이 매우 높음을 의미한다. Radix Tree는 공통된 접두사(Prefix)를 하나의 부모 노드로 묶어 저장함으로써 중복된 데이터를 획기적으로 줄인다. 이는 메모리가 곧 비용인 인메모리 DB에서 필수적인 최적화이다.
2. **Macro Nodes와 Listpacks:** Rax의 각 노드는 단일 메시지만을 저장하지 않는다. Redis는 메모리 파편화(Fragmentation)와 포인터 오버헤드를 줄이기 위해 **매크로 노드(Macro Nodes)**라는 개념을 도입했다. 하나의 노드 안에 수십~수백 개의 메시지를 **Listpack**(과거 ziplist의 개선판)이라는 고도로 압축된 선형 메모리 블록에 욱여넣는다.
  - **메모리 효율:** 각 메시지마다 별도의 객체 메타데이터나 포인터가 필요 없다.
  - **캐시 지역성(Cache Locality):** 연속된 메모리 공간에 데이터가 밀집되어 있어, CPU 캐시 히트율을 높이고 범위 검색(XRANGE) 성능을 극대화한다. 이 구조 덕분에 Redis Streams는 수백만 건의 메시지를 저장하면서도 획기적으로 적은 메모리를 사용한다.
3. **검색 성능:** Radix Tree는 $O(K)$ (K는 키의 길이)의 시간 복잡도로 데이터에 접근하며, 범위 검색에 최적화되어 있어 시계열 데이터 조회에 탁월한 성능을 발휘한다.

출처: https://redis.io/technology/data-structures/

출처: https://redisgate.jp/redis/configuration/internal_rax.php

출처: https://antirez.com/news/128

출처: https://redis.io/technology/data-structures/


### **3.2 Consumer Groups: 샤딩(Sharding)과 팬아웃(Fan-out)**
<img width="250" height="200" alt="image" src="https://github.com/user-attachments/assets/8eb24127-fda5-4b99-9594-cd5493ba2d88" />

Consumer Group은 Kafka의 설계를 차용하였으나 Redis 특유의 단순함을 유지하며 구현되었다.

- **논리적 상태 관리:** Consumer Group은 스트림 데이터 자체를 복제하지 않는다. 대신, 스트림 내에서 "이 그룹이 어디까지 읽었는가"를 나타내는 **커서(Cursor, last_delivered_id)**만을 관리한다.
- **샤딩(Sharding - Load Balancing):** 그룹 내의 소비자(Consumer A, Consumer B)가 XREADGROUP 명령을 호출할 때 특수 ID인 >를 사용하면, Redis는 해당 그룹에게 아직 전달되지 않은 **새로운 메시지**를 각 소비자에게 라운드 로빈 등의 방식으로 분배한다. 이를 통해 하나의 스트림 처리 부하를 여러 서버가 나누어 가질 수 있다.
- **팬아웃(Fan-out - Broadcasting):** 서로 다른 Consumer Group(예: Group 1, Group 2)은 독립적인 커서를 가진다. 따라서 Group 1이 메시지를 소비하더라도 Group 2의 커서에는 영향을 주지 않으므로, 동일한 메시지가 각 그룹에 모두 전달된다. 이는 하나의 이벤트 소스로부터 로그 적재, 알림 발송, 실시간 분석을 동시에 수행하는 아키텍처를 가능케 한다.

출처: https://redis.io/docs/latest/develop/data-types/streams/

출처: https://redis.io/resources/understanding-streams-in-redis-and-kafka-ebook.pdf

출처: https://medium.com/redis-with-raphael-de-lio/understanding-redis-streams-33aa96ca7206


### **3.3 Pending Entries List (PEL)와 장애 복구(Failover)**

분산 시스템에서 소비자의 장애는 필연적이다. Redis는 **PEL (Pending Entries List)**을 통해 "메시지를 전달했으나 처리가 완료되지 않은 상태"를 관리한다.

1. **PEL의 생성:** 소비자가 XREADGROUP으로 메시지를 읽어가는 순간, 해당 메시지는 스트림에서 삭제되지 않고 해당 소비자의 PEL에 등록된다. 이때 메시지의 상태는 'Pending'이 되며, '마지막 전달 시간'과 '전달 횟수'가 기록된다.
2. **정상 처리 (ACK):** 소비자가 처리를 성공적으로 마치고 XACK를 보내면, Redis는 해당 메시지를 PEL에서 제거한다. 이것이 처리 완료의 신호이다.
3. **장애 시나리오와 복구 (Failover):** 소비자가 메시지를 가져간 후 크래시(Crash)되어 XACK를 보내지 못하면, 메시지는 영원히 PEL에 남게 된다. 이를 해결하기 위해 다른 소비자(또는 복구 프로세스)가 XAUTOCLAIM 또는 XCLAIM 명령을 사용한다.
- **XCLAIM/XAUTOCLAIM:** "특정 시간(min-idle-time) 이상 방치된 메시지"를 검색하여 소유권을 자신에게로 가져온다. 소유권이 이전되면 배달 횟수(delivery counter)가 증가하고, 새로운 소비자가 처리를 재시도할 수 있다. 이는 **At-least-once (최소 1회)** 전달을 보장하는 핵심 메커니즘이다.
- **Dead Letter 처리:** 배달 횟수가 임계치를 초과한 메시지는 처리 불가능한 '독성 메시지(Poison Pill)'로 간주하여 별도의 에러 큐로 이동시키거나 삭제(XDEL)하는 애플리케이션 레벨의 로직이 필요하다.


출처: https://blog.stackademic.com/redis-stream-with-go-from-queue-creation-to-reliable-message-retries-65ad5ac71c0c

출처: https://medium.com/redis-with-raphael-de-lio/understanding-redis-streams-33aa96ca7206

출처: https://valkey.io/topics/streams-intro/

출처: https://redis.io/docs/latest/commands/xautoclaim/

출처: https://redis.io/docs/latest/develop/data-types/streams/


---

## **4. 신뢰성 및 운영 전략 (Reliability & Operations)**

Redis를 프로덕션 환경의 메시지 브로커로 사용할 때 가장 우려되는 점은 인메모리 특성으로 인한 데이터 휘발성이다. 이를 보완하기 위한 운영 전략과 설정 최적화가 필수적이다.

### **4.1 전달 보장 (Delivery Semantics)**

Redis는 설정과 사용 방식에 따라 서로 다른 수준의 전달 보장을 제공한다.

- **At-most-once (최대 1회):** Pub/Sub의 기본 동작이다. 메시지는 발송되지만 수신 확인은 없다. 유실되어도 무방한 데이터에 적합하다.
- **At-least-once (최소 1회):** Streams와 Consumer Group을 사용할 때의 기본 보장이다. 메시지는 디스크(AOF)에 기록되고, 소비자가 XACK를 보낼 때까지 PEL에 유지된다. 장애 발생 시 XCLAIM을 통해 재전송되므로 데이터 유실은 없으나, **중복 처리(Duplicate Processing)** 가능성이 있다. 따라서 소비자는 멱등성(Idempotency)을 갖추도록 설계되어야 한다.
- **Exactly-once (정확히 1회):** Redis 자체적으로 Kafka와 같은 트랜잭션 기반의 정확히 1회 처리를 완벽하게 보장하지는 않는다. 그러나 Redis Streams의 ID는 고유하므로, 소비자가 처리한 ID를 별도의 저장소(또는 Redis Set)에 기록하여 중복을 방지하는 방식으로 애플리케이션 레벨에서 이를 근사하게 구현할 수 있다.


출처: https://redis.io/docs/latest/develop/pubsub/

출처: https://blog.stackademic.com/redis-stream-with-go-from-queue-creation-to-reliable-message-retries-65ad5ac71c0c

출처: https://redis.io/docs/latest/integrate/redis-data-integration/architecture/

출처: https://www.geeksforgeeks.org/system-design/difference-between-redis-pub-sub-vs-redis-streams/

### **4.2 지속성(Persistence)과 데이터 유실 시나리오**

Redis는 기본적으로 메모리에 데이터를 저장하므로 전원 차단 시 데이터가 유실된다. 이를 방지하기 위해 **AOF (Append Only File)** 기능을 사용해야 한다.

- **AOF 메커니즘:** 모든 쓰기 명령(메시지 발행 포함)을 파일에 순차적으로 기록한다. 재시작 시 이 파일을 다시 읽어 메모리 상태를 복구한다.
- **fsync 정책과 트레이드오프:**
- appendfsync always: 모든 메시지마다 디스크 동기화를 수행한다. 데이터 유실은 거의 없으나, 디스크 I/O 속도에 의해 처리량이 급격히 저하된다(수십만 OPS -> 수백 OPS). 브로커로서의 성능 이점을 잃게 된다.
- appendfsync everysec (권장): 1초마다 백그라운드에서 디스크 동기화를 수행한다. 성능 저하는 미미하지만, 전원 차단 시 **최대 1초 분량의 메시지가 유실**될 수 있다. 대부분의 고성능 브로커 시나리오에서 이는 허용 가능한 타협점으로 간주된다.
- appendfsync no: OS에게 동기화를 위임한다. 가장 빠르지만 데이터 안전성은 가장 낮다.

출처: https://redis.io/docs/latest/operate/oss_and_stack/management/optimization/latency/

출처: https://redis.io/docs/latest/operate/oss_and_stack/management/persistence/

출처: https://redis.io/docs/latest/operate/oss_and_stack/management/persistence/

출처: https://codemia.io/knowledge-hub/path/asynchronous_aof_fsync_is_taking_too_long_disk_is_busy_writing_the_aof_buffer_without_waiting_for_fsync_to_complete_this_may_slow_down_redis

출처: https://medium.com/@sohail_saifi/how-redis-persistence-actually-works-and-when-it-fails-c3715d11529f

### **4.3 메모리 관리와 Eviction**

Redis는 RAM 용량의 물리적 한계를 가진다. 스트림에 메시지가 무한정 쌓이면 결국 OOM(Out of Memory) 오류가 발생하여 서버가 중단된다.

- **MAXLEN을 통한 길이 제한:** XADD 명령 시 MAXLEN 옵션을 사용하여 스트림의 최대 길이를 제한해야 한다. 이는 오래된 메시지를 자동으로 삭제(Eviction)하는 원형 버퍼(Ring Buffer) 효과를 낸다.
- **성능 최적화 (~ 사용):** MAXLEN 1000과 같이 정확한 길이를 지정하면, Redis는 정확히 1000개를 맞추기 위해 내부 노드를 재조정해야 할 수 있어 CPU 비용이 든다. 대신 MAXLEN ~ 1000 (근사치 트리밍)을 사용하면, Redis는 매크로 노드 단위로 삭제를 수행하여 약간의 오차를 허용하는 대신 매우 효율적으로 메모리를 회수할 수 있다. 이는 고성능 시스템에서 필수적인 최적화 기법이다.
- **XDEL 사용 주의:** 개별 메시지를 XDEL로 삭제하는 것은 가능하지만, 이는 매크로 노드 내의 압축 효율을 떨어뜨리고 단편화를 유발할 수 있으므로, 대량의 메시지 처리에서는 MAXLEN이나 XTRIM을 사용하는 것이 바람직하다.

출처: https://redis.io/docs/latest/develop/data-types/streams/

---

## **5. 비교 및 기술 선정 (Comparison & Selection)**

Redis를 브로커로 선택할지, 아니면 Kafka나 RabbitMQ와 같은 전문 솔루션을 도입할지는 시스템의 요구사항에 따라 결정된다.

### **5.1 Redis vs Kafka: 메모리 대 디스크**

| **비교 항목** | **Redis Streams** | **Apache Kafka** |
| --- | --- | --- |
| **저장 매체** | **In-Memory (RAM)** | **Disk (Log Files)** |
| **성능 (Latency)** | **Sub-millisecond** (극초고속)  | Low-ms (디스크/배치 처리에 따른 지연) |
| **처리량 (Throughput)** | 높음 (단일 스레드 CPU 한계) | **매우 높음** (파티션 기반 수평 확장 용이)  |
| **데이터 보존** | 메모리 용량 제한 (주로 단기 보관) | 디스크 용량만큼 무제한 (장기 로그 보관 가능) |
| **복잡도** | 낮음 (기존 Redis 인프라 활용 가능) | 높음 (Zookeeper/KRaft, 별도 클러스터 운영)  |
| **적합한 사용처** | 실시간성이 중요한 단기 이벤트 버퍼 | 대용량 로그 수집 및 장기 데이터 파이프라인 |

**결정적 차이:** 대용량의 로그를 며칠, 몇 달간 보관하며 재처리해야 하거나(Retention), 초당 수백만 건 이상의 처리량이 필요하다면 **Kafka**가 적합하다. 반면, 즉각적인 응답이 필요하고 데이터 보관 기간이 짧으며 운영 복잡도를 낮추고 싶다면 **Redis Streams**가 우수하다.

출처: https://github.com/AutoMQ/automq/wiki/Apache-Kafka-vs.-RabbitMQ:-Differences-&-Comparison

출처: https://logit.io/blog/post/rabbitmq-vs-kafka-vs-redis/

출처: https://blog.devops.dev/benchmarking-redis-dragonfly-kafka-mqtt-and-rabbitmq-for-high-load-messaging-5a6ca8c2b853

### **5.2 Redis vs RabbitMQ: 라우팅 유연성**

| **비교 항목** | **Redis Streams** | **RabbitMQ** |
| --- | --- | --- |
| **라우팅 방식** | 단순함 (Key 기반, Consumer Group) | **복잡함** (Exchange, Routing Key, Binding)  |
| **브로커 역할** | Dumb Broker (단순 전달 및 저장) | **Smart Broker** (복잡한 라우팅/필터링 로직 수행)  |
| **우선순위 큐** | 미지원 (별도 구현 필요) | 기본 지원 |
| **프로토콜** | RESP (Redis 자체 프로토콜) | AMQP (표준 메시징 프로토콜) |
| **적합한 사용처** | 고속 스트림 처리, 단순 팬아웃 | 복잡한 라우팅 규칙이 필요한 엔터프라이즈 메시징 |

**결정적 차이:** RabbitMQ는 "특정 헤더를 가진 메시지만 A 큐로 보내고 나머지는 B 큐로 보내라"와 같은 복잡한 라우팅이 필요할 때 강점을 가진다. Redis는 이러한 로직을 애플리케이션 레벨에서 처리해야 하는 비용이 발생하지만, 단순한 구조 덕분에 훨씬 높은 처리 속도를 제공한다.

출처: https://aws.amazon.com/compare/the-difference-between-rabbitmq-and-redis/

출처: https://github.com/AutoMQ/automq/wiki/Apache-Kafka-vs.-RabbitMQ:-Differences-&-Comparison

출처: https://airbyte.com/data-engineering-resources/redis-vs-rabbitmq

출처: https://aws.amazon.com/compare/the-difference-between-rabbitmq-and-redis/

### **5.3 결론: 왜 Redis를 브로커로 선택하는가?**

Redis는 "모든 것을 해결하는 만능열쇠"는 아니지만, **속도(Performance), 단순성(Simplicity), 기능성(Functionality)**의 균형점에서 독보적인 위치를 점하고 있다. 특히 Streams의 도입으로 인해 지속성과 소비자 그룹 관리가 가능해지면서, 마이크로서비스 간의 비동기 통신을 위한 경량화된 고성능 브로커로서 충분한 자격을 갖추게 되었다.

복잡한 설정과 무거운 인프라 없이도 즉시 사용 가능한 **Redis Streams**는, 데이터의 영구 보존보다는 **실시간 처리와 시스템의 기민함**이 우선시되는 현대적인 클라우드 네이티브 애플리케이션에서 가장 합리적인 선택지가 될 것이다.








